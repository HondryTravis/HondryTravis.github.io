<!doctype html>
<html class="docs-version-current" lang="zh-Hans" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.8">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="TRAVIS RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="TRAVIS Atom Feed"><title data-react-helmet="true">Tree | 树 | TRAVIS</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hondrytravis.github.io//algorithm/data_structure/tree"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-Hans"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-algorithm-current"><meta data-react-helmet="true" property="og:title" content="Tree | 树 | TRAVIS"><meta data-react-helmet="true" name="description" content="树的具体定义"><meta data-react-helmet="true" property="og:description" content="树的具体定义"><link data-react-helmet="true" rel="shortcut icon" href="/images/default/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hondrytravis.github.io//algorithm/data_structure/tree"><link data-react-helmet="true" rel="alternate" href="https://hondrytravis.github.io//algorithm/data_structure/tree" hreflang="zh-Hans"><link data-react-helmet="true" rel="alternate" href="https://hondrytravis.github.io//algorithm/data_structure/tree" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.673bc2ec.css">
<link rel="preload" href="/assets/js/runtime~main.261a0b30.js" as="script">
<link rel="preload" href="/assets/js/main.d8aec2c2.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">跳到主要内容</a></div><nav class="navbar navbar--fixed-top navbar--dark navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/images/default/Logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/images/default/Logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">Better Late Than Never</b></a><a class="navbar__item navbar__link" href="/docs">博客</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/algorithm/">算法</a><a class="navbar__item navbar__link" href="/open_source/"> 开源贡献</a><a class="navbar__item navbar__link" href="/blog">阅读</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/HondryTravis" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/"><img src="/images/default/Logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/images/default/Logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m"><b>Better Late Than Never</b></a><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/algorithm/">算法</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">算法导论</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">数据结构</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/algorithm/data_structure/linked_list">LinkedList | 链表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/algorithm/data_structure/stack">Stack | 栈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/algorithm/data_structure/queue">Queue | 队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/algorithm/data_structure/tree">Tree | 树</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">栈</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">队列</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">链表</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">双指针</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">树</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">堆</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">哈希</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">动态规划</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">数组</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">字符串</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">排序</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">位运算</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">趣味算法</a></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Tree | 树</h1></header><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="树的具体定义">树的具体定义<a aria-hidden="true" class="hash-link" href="#树的具体定义" title="标题的直接链接">​</a></h2><p>既然已经有循序表，链表，队列等线性结构了，应该满足任何需求了吗？</p><p>不是的，想企业架构图谱，关系图，地图(四叉树)，家庭关系族谱等……，所以很多关系并不是常规的线性结构就可以表示的，常常存在这一对多，多对多的关系，比如 dom 树，目录树，等等
类似这样</p><p>企业的职级关系和家庭关系</p><table><thead><tr><th align="center"><img src="/assets/images/enterprise_construct_01-a556ef5bfed35d3496b415f49490c3b5.png"></th><th align="center"><img src="/assets/images/family_relation_01-1f4006f60e2891ba1c5941c8230f7a93.png"></th></tr></thead></table><p>它们之间的关系都像自然界中的树一样，从同一个“根”衍生出许多“枝干”，再从每一个“枝干”衍生出许多更小的“枝干”，最后衍生出更多的“叶子”。</p><p style="color:red">树（tree）是 n（n≥0）个节点的有限集。当 n=0 时，称为空树。在任意一个非空树中，有如下特点。</p><ol><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。</li></ol><img src="/images/algorithm/tree_01.png" width="400" height="400" alt="tree"><p>在上图中，节点1是根节点（root）; 节点5、6、7、8是树的末端，没有“孩子”，被称为叶子节点（leaf）。图中的虚线部分，是根节点 1 的其中一个子树。</p><p>同时，树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如 <strong>下图</strong>。</p><img src="/images/algorithm/tree_02.png" width="500" height="400" alt="tree"><p>节点 4 的上一级节点，是节点 4 的父节点（parent）;从节点4衍生出来的节点，是节点 4 的孩子节点（child）;和节点 4 同级，由同一个父节点衍生出来的节点，是节点 4 的兄弟节点（sibling）。</p><p>树的最大层级数，被称为树的高度或深度。显然，上图这两颗树的高度是4。</p><p>看看最典型的 🌲</p><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="什么是二叉树">什么是二叉树<a aria-hidden="true" class="hash-link" href="#什么是二叉树" title="标题的直接链接">​</a></h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点。</p><img src="/images/algorithm/binary_tree_01.png" width="400" height="400" alt="tree"><p>二叉树节点的两个孩子节点，一个被称为左孩子（left child），一个被称为右孩子（right child）。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p><p>此外，二叉树还有两种特殊形式，一个叫作 <strong>满二叉树</strong>，另一个叫作 <strong>完全二叉树</strong>。</p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="满二叉树">满二叉树<a aria-hidden="true" class="hash-link" href="#满二叉树" title="标题的直接链接">​</a></h3><p>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</p><p><img src="/assets/images/binary_tree_all_01-a5c471d62399ef5ceed3d365845178e7.png"></p><p>简单点说，满二叉树的每一个分支都是满的。</p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="完全二叉树">完全二叉树<a aria-hidden="true" class="hash-link" href="#完全二叉树" title="标题的直接链接">​</a></h3><p>对一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n。如果这个树所有节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为完全二叉树。</p><p><img src="/assets/images/binary_tree_all_02-d0aa0f59a04f2624f88b1e2e6693f35c.png"></p><p>在上图中，二叉树编号从 1 到 12 的 12 个节点，和前面满二叉树 编号从 1 到 12 的节点位置完全对应。因此这个树是完全二叉树。</p><p style="color:red">完全二叉树的条件没有满二叉树那么苛刻: 满二叉树要求所有分支都是满的;而完全二叉树只需保证最后一个节点之前的节点都齐全即可。</p><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="二叉树的存储">二叉树的存储<a aria-hidden="true" class="hash-link" href="#二叉树的存储" title="标题的直接链接">​</a></h2><ol><li>链式存储</li><li>数组</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="链式存储">链式存储<a aria-hidden="true" class="hash-link" href="#链式存储" title="标题的直接链接">​</a></h3><img src="/images/algorithm/binary_tree_linkedlist_01.png" width="500" height="500" alt="tree"><p>链式存储是二叉树最直观的存储方式</p><p>链表是一对一的存储方式，每一个链表节点拥有data变量和一个指向下一节点的next指针。而二叉树稍微复杂一些，一个节点最多可以指向左右两个孩子节点，所以二叉树的每一个节点包含 3 部分。</p><ul><li>存储数据的 <code>data</code> 变量</li><li>指向左孩子的 <code>left</code> 指针</li><li>指向右孩子的 <code>right</code> 指针</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="数组存储">数组存储<a aria-hidden="true" class="hash-link" href="#数组存储" title="标题的直接链接">​</a></h3><img src="/images/algorithm/binary_tree_array_01.png" width="450" height="400" alt="tree"><p>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。 如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p><p>为什么这样设计呢？因为这样可以更方便地在数组中定位二叉树的孩子节点和父节点。</p><p>假设一个父节点的下标是 parent，那么它的左孩子节点下标就是 <code>2 * parent + 1</code>;</p><p>右孩子节点下标就是 <code>2 * parent + 2</code>。</p><p>反过来，假设一个左孩子节点的下标是 leftChild，那么它的父节点下标就是 <code>(leftChild - 1)/ 2</code>。</p><p>假如节点 4 在数组中的下标是 3，节点 4 是节点 2 的左孩子，节点 2 的下标可以直接通过计算得出。</p><p>节点2的下标 = <code>(3 - 1)/2 = 1</code></p><p style="color:red">显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><p>什么样的二叉树最适合用数组表示呢？--二叉堆</p><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="二叉树的应用">二叉树的应用<a aria-hidden="true" class="hash-link" href="#二叉树的应用" title="标题的直接链接">​</a></h2><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行 <strong>查找操作</strong> 和维持 <strong>相对顺序</strong> 这两个方面。</p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="查找">查找<a aria-hidden="true" class="hash-link" href="#查找" title="标题的直接链接">​</a></h3><p>二叉树的树形结构使它很适合扮演索引的角色。</p><p>这里我们介绍一种特殊的二叉树：二叉查找树（binary search tree）。</p><p><strong>二叉查找树在二叉树的基础上增加了以下几个条件。</strong></p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</li><li>左、右子树也都是二叉查找树</li></ul><img src="/images/algorithm/binary_search_tree_01.png" width="600" height="400" alt="tree"><p>二叉查找树的这些条件有什么用呢？当然是为了查找方便。</p><p>例如查找值为4的节点，步骤如下。</p><ol><li><p>访问根节点6，发现4&lt;6。</p><img src="/images/algorithm/binary_search_tree_02.png" width="600" height="400" alt="tree"></li><li><p>访问节点6的左孩子节点3，发现4&gt;3。</p><img src="/images/algorithm/binary_search_tree_03.png" width="600" height="400" alt="tree"></li><li><p>访问节点3的右孩子节点4，发现4=4，这正是要查找的节点。</p><img src="/images/algorithm/binary_search_tree_04.png" width="600" height="400" alt="tree"></li></ol><p>对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是 n，那么搜索节点的时间复杂度就是 O(logn)，和树的深度是一样的。</p><p>这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。</p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="维持相对顺序">维持相对顺序<a aria-hidden="true" class="hash-link" href="#维持相对顺序" title="标题的直接链接">​</a></h3><p>这一点仍然要从二叉查找树说起。二叉查找树要求左子树小于父节点，右子树 大于父节点，正是这样保证了二叉树的有序性。</p><p>因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。</p><p>新插入的节点，同样要遵循二叉排序树的原则。例如插入新元素5，由于5&lt;6，5&gt;3，5&gt;4，所以5最终会插入到节点4的右孩子位置。</p><img src="/images/algorithm/binary_sort_tree_05.png" width="600" height="400" alt="tree"><p>再如插入新元素10，由于10&gt;6，10&gt;8，10&gt;9，所以10最终会插入到节点 9 的右孩子位置。</p><img src="/images/algorithm/binary_sort_tree_06.png" width="600" height="400" alt="tree"><p>这一切看起来很顺利，然而却隐藏着一个致命的问题。什么问题呢？下面请试着在二叉查找树中依次插入9、8、7、6、5、4，看看会出现什么结果。</p><img src="/images/algorithm/binary_sort_tree_07.png" width="400" height="500" alt="tree"><p>怎么解决这个问题呢？这就涉及二叉树的自平衡了。二叉树自平衡的方式有多种，如红黑树、AVL树、树堆等</p><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="二叉树的遍历">二叉树的遍历<a aria-hidden="true" class="hash-link" href="#二叉树的遍历" title="标题的直接链接">​</a></h2><p>在计算机程序中，遍历本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情但是二叉树不一样，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同。</p><img src="/images/algorithm/binary_tree_iterator_01.png" width="500" height="400" alt="tree"><p>那么，二叉树都有哪些遍历方式呢？</p><p>从节点之间位置关系的角度来看，二叉树的遍历分为4种。</p><ol><li>前序遍历</li><li>中序遍历</li><li>后续遍历</li><li>层序遍历</li></ol><p><strong>从更宏观的角度来看，二叉树的遍历归结为两大类。</strong></p><ol><li>深度优先遍历（前序遍历、中序遍历、后序遍历）。</li><li>广度优先遍历（层序遍历）。</li></ol><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="深度优先遍历-dfs">深度优先遍历 dfs<a aria-hidden="true" class="hash-link" href="#深度优先遍历-dfs" title="标题的直接链接">​</a></h2><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。</p><p>所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底” 的访问方式。可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍历、后序遍历，来看一看深度优先是怎么回事吧。</p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="前序遍历-preorder-traversal-vlr">前序遍历 Preorder Traversal (VLR)<a aria-hidden="true" class="hash-link" href="#前序遍历-preorder-traversal-vlr" title="标题的直接链接">​</a></h3><p>二叉树的前序遍历，输出顺序是根节点、左子树、右子树。</p><img src="/images/algorithm/binary_tree_vlr_01.png" width="500" height="400" alt="tree"><p>顺序如上</p><table><thead><tr><th align="center"><img src="/assets/images/binary_tree_vlr_02-97ca810e50511f48067a8cb2024f6d7c.png"></th><th align="center"><img src="/assets/images/binary_tree_vlr_03-b37666d711c59f8dcbf9587dc5f0ec78.png"></th><th align="center"><img src="/assets/images/binary_tree_vlr_04-39f1e53f5396c479f55676e034075f0e.png"></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center"><img src="/assets/images/binary_tree_vlr_05-d68d424a3027aaef204ef3cd05f22d32.png"></td><td align="center"><img src="/assets/images/binary_tree_vlr_06-2b9d4d10f2e8698ee396b6788f793803.png"></td><td align="center"><img src="/assets/images/binary_tree_vlr_07-ac291eee41bfd76ee3a137f3852a1ecf.png"></td></tr><tr><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><ol><li>首先输出的是根节点1。</li><li>由于根节点1存在左孩子，输出左孩子节点2。</li><li>由于节点2也存在左孩子，输出左孩子节点4</li><li>节点4既没有左孩子，也没有右孩子，那么回到节点2，输出节点2的右孩子节点5。</li><li>节点5既没有左孩子，也没有右孩子，那么回到节点1，输出节点1的右孩子节点3。</li><li>节点3没有左孩子，但是有右孩子，因此输出节点3的右孩子节点6。</li></ol><p>到此为止，所有的节点都遍历输出完毕。</p><p><a href="/algorithm/stack/index#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的前序遍历</a></p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="中序遍历-inorder-traversal-ldr">中序遍历 Inorder Traversal (LDR)<a aria-hidden="true" class="hash-link" href="#中序遍历-inorder-traversal-ldr" title="标题的直接链接">​</a></h3><p>二叉树的中序遍历，输出顺序是左子树、根节点、右子树。</p><img src="/images/algorithm/binary_tree_ldr_01.png" width="500" height="400" alt="tree"><p>顺序如上</p><table><thead><tr><th align="center"><img src="/assets/images/binary_tree_ldr_02-7f576c9a99a4757cd7663509c2338fb8.png"></th><th align="center"><img src="/assets/images/binary_tree_ldr_03-7aa06568b23fa3d90a3314561184bec3.png"></th><th align="center"><img src="/assets/images/binary_tree_ldr_04-01a3cb60d01fd755ae960c32b062ed58.png"></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center"><img src="/assets/images/binary_tree_ldr_05-7ec155fb2d80debe723919030d80b261.png"></td><td align="center"><img src="/assets/images/binary_tree_ldr_06-68e974eb7d42abbc19673110b96940a3.png"></td><td align="center"><img src="/assets/images/binary_tree_ldr_07-75dce03d1157f296dcca8c8305b7ff3c.png"></td></tr><tr><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><ol><li>首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，一直找到不再有左孩子的节点，并输出该节点。显然，第一个没有左孩子的 节点是节点4。</li><li>依照中序遍历的次序，接下来输出节点4的父节点2。</li><li>再输出节点2的右孩子节点5。</li><li>以节点2为根的左子树已经输出完毕，这时再输出整个二叉树的根节点1。</li><li>由于节点3没有左孩子，所以直接输出根节点1的右孩子节点3。</li><li>最后输出节点3的右孩子节点6。</li></ol><p><a href="/algorithm/stack/index#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的中序遍历</a></p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="后序遍历-postorder-traversal-lrd">后序遍历 Postorder Traversal (LRD)<a aria-hidden="true" class="hash-link" href="#后序遍历-postorder-traversal-lrd" title="标题的直接链接">​</a></h3><p>二叉树的后序遍历，输出顺序是左子树、右子树、根节点。</p><img src="/images/algorithm/binary_tree_lrd_01.png" width="500" height="400" alt="tree"><p>上图就是一个二叉树的后序遍历，每个节点左侧的序号代表该节点的输出顺序。</p><p><a href="/algorithm/stack/index#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的后序遍历</a></p><h2 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="广度优先遍历-bfs">广度优先遍历 bfs<a aria-hidden="true" class="hash-link" href="#广度优先遍历-bfs" title="标题的直接链接">​</a></h2><p>深度遍历就像是上楼梯，每层楼有四个工作室，你一路之上，一头扎到顶，每一层其他工作室你都先不看，最后在回来挨个看。而层序遍历就是一层一层都看完在上去。这也就是层序遍历，<strong>顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点</strong>。</p><h3 class="anchor anchorWithHideOnScrollNavbar_3R7-" id="层序遍历">层序遍历<a aria-hidden="true" class="hash-link" href="#层序遍历" title="标题的直接链接">​</a></h3><img src="/images/algorithm/binary_tree_flat_01.png" width="550" height="400" alt="tree"><p>上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输出顺序。</p><p>这里同样需要借助一个数据结构来辅助工作，这个数据结构就是队列</p><p>详细遍历步骤如下</p><table><thead><tr><th align="center"><img src="/assets/images/binary_tree_flat_02-8bd093c518311b7cc10b3e1f69a2185d.png"></th><th align="center"><img src="/assets/images/binary_tree_flat_03-080a579515cca38f3945d2b8d9275f91.png"></th><th align="center"><img src="/assets/images/binary_tree_flat_04-7bf10b192106d755f43dfda243f8a7de.png"></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center"><img src="/assets/images/binary_tree_flat_05-7a12871fdeccf78a72ed7561c4350cea.png"></td><td align="center"><img src="/assets/images/binary_tree_flat_06-7da2d90a0ae3bd387240cab161bb576e.png"></td><td align="center"><img src="/assets/images/binary_tree_flat_07-eb307daec0f49acde5783e51c651e353.png"></td></tr><tr><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr></tbody></table><ol><li>根节点1进入队列。</li><li>节点1出队，输出节点1，并得到节点1的左孩子节点2、右孩子节点3。让节点2和节点3入队。</li><li>节点2出队，输出节点2，并得到节点2的左孩子节点4、右孩子节点5。让节点4和节点5入队。</li><li>节点3出队，输出节点3，并得到节点3的右孩子节点6。让节点6入队。</li><li>节点4出队，输出节点4，由于节点4没有孩子节点，所以没有新节点入队。</li><li>节点5出队，输出节点5，由于节点5同样没有孩子节点，所以没有新节点入队。</li><li>节点6出队，输出节点6，节点6没有孩子节点，没有新节点入队。</li></ol><img src="/images/algorithm/binary_tree_flat_08.png" width="550" height="400" alt="tree"><p>到此为止，所有的节点都遍历输出完毕。</p><p><a href="/algorithm/queue/index#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的层序遍历</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/HondryTravis/Blog/tree/master/packages/algorithm/data_structure/tree.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_13-_"><span class="theme-last-updated">最后<!-- -->由 <b>travis</b> <!-- -->于 <b><time datetime="2022-12-06T11:14:09.000Z">2022/12/6</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/algorithm/data_structure/queue"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">« <!-- -->Queue | 队列</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/algorithm/stack/index"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">stack | 栈<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#树的具体定义" class="table-of-contents__link toc-highlight">树的具体定义</a></li><li><a href="#什么是二叉树" class="table-of-contents__link toc-highlight">什么是二叉树</a><ul><li><a href="#满二叉树" class="table-of-contents__link toc-highlight">满二叉树</a></li><li><a href="#完全二叉树" class="table-of-contents__link toc-highlight">完全二叉树</a></li></ul></li><li><a href="#二叉树的存储" class="table-of-contents__link toc-highlight">二叉树的存储</a><ul><li><a href="#链式存储" class="table-of-contents__link toc-highlight">链式存储</a></li><li><a href="#数组存储" class="table-of-contents__link toc-highlight">数组存储</a></li></ul></li><li><a href="#二叉树的应用" class="table-of-contents__link toc-highlight">二叉树的应用</a><ul><li><a href="#查找" class="table-of-contents__link toc-highlight">查找</a></li><li><a href="#维持相对顺序" class="table-of-contents__link toc-highlight">维持相对顺序</a></li></ul></li><li><a href="#二叉树的遍历" class="table-of-contents__link toc-highlight">二叉树的遍历</a></li><li><a href="#深度优先遍历-dfs" class="table-of-contents__link toc-highlight">深度优先遍历 dfs</a><ul><li><a href="#前序遍历-preorder-traversal-vlr" class="table-of-contents__link toc-highlight">前序遍历 Preorder Traversal (VLR)</a></li><li><a href="#中序遍历-inorder-traversal-ldr" class="table-of-contents__link toc-highlight">中序遍历 Inorder Traversal (LDR)</a></li><li><a href="#后序遍历-postorder-traversal-lrd" class="table-of-contents__link toc-highlight">后序遍历 Postorder Traversal (LRD)</a></li></ul></li><li><a href="#广度优先遍历-bfs" class="table-of-contents__link toc-highlight">广度优先遍历 bfs</a><ul><li><a href="#层序遍历" class="table-of-contents__link toc-highlight">层序遍历</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">快速了解</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/performance/page_performance_index">如何监控页面性能指标</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/thinking/design_patterns">设计模式</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/thinking/functional_programming">函数式编程</a></li></ul></div><div class="col footer__col"><div class="footer__title">学习</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/algorithm/">算法</a></li></ul></div><div class="col footer__col"><div class="footer__title">开源贡献</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/open_source/cli/tscli">tscli</a></li><li class="footer__item"><a class="footer__link-item" href="/open_source/github/indexeddb">Indexeddb</a></li><li class="footer__item"><a class="footer__link-item" href="/open_source/github/tinydb_docapi">TinyDB</a></li><li class="footer__item"><a class="footer__link-item" href="/open_source/vscode/Simple-dark">Simple dark</a></li><li class="footer__item"><a href="https://github.com/HondryTravis/xs-docs" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>xs-doc<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/myliang/x-spreadsheet" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>x-spreadsheet<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">联系方式</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/contact">邮箱 | 联系方式</a></li></ul></div><div class="col footer__col"><div class="footer__title">友情链接</div><ul class="footer__items"><li class="footer__item"><a href="https://kalacloud.com" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>卡拉云低代码工具<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">AGPL-3.0 Licensed | Copyright © 2020-present HondryTravis, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.261a0b30.js"></script>
<script src="/assets/js/main.d8aec2c2.js"></script>
</body>
</html>